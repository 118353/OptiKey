public static class DiagnosticInfo
{
    private static const string uacRegistryKey = "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System";
    private static const string uacRegistryValue = "EnableLUA";

    private static uint STANDARD_RIGHTS_READ = 0x00020000;
    private static uint TOKEN_QUERY = 0x0008;
    private static uint TOKEN_READ = (STANDARD_RIGHTS_READ | TOKEN_QUERY);

    public static string AssemblyVersion
    {
        get
        {
            return ((System.Reflection.AssemblyVersionAttribute)(System.Reflection.Assembly.GetExecutingAssembly().GetCustomAttributes(
                typeof(System.Reflection.AssemblyVersionAttribute), false)[0])).Version;
        }
    }

    public static string AssemblyFileVersion
    {
        get
        {
            return ((System.Reflection.AssemblyFileVersionAttribute)(System.Reflection.Assembly.GetExecutingAssembly().GetCustomAttributes(
                typeof(System.Reflection.AssemblyFileVersionAttribute), false)[0])).Version;
        }
    }

    public static bool IsApplicationNetworkDeployed
    {
        get
        {
            return System.Deployment.Application.ApplicationDeployment.IsNetworkDeployed;
        }
    }

    public static string DeploymentVersion
    {
        get
        {
            return System.Deployment.Application.ApplicationDeployment.CurrentDeployment.CurrentVersion;
        }
    }
    
    public static bool RunningAsAdministrator
    {
        get { return new WindowsPrincipal(WindowsIdentity.GetCurrent()).IsInRole(WindowsBuiltInRole.Administrator); }
    }

    public static string ProcessBitness
    {
        get { return Environment.Is64BitProcess ? "64-Bit" : "32-Bit"; }
    }

    public static string OperatingSystemBitness
    {
        get { return Environment.Is64BitOperatingSystem ? "64-Bit" : "32-Bit"; }
    }

    public static string OperatingSystemVersion
    {
        get
        {
            Version vs = Environment.OSVersion.Version;

            switch (vs.Major)
            {
                case 3:
                    return "Windows NT 3.51";

                case 4:
                    return "Windows NT 4.0";

                case 5:
                    if (vs.Minor == 0) return "Windows 2000";

                    if (vs.Minor == 1) return "Windows XP";

                    if (IsServerVersion())
                    {
                        if (WindowsAPI.GetSystemMetrics(89) == 0) return "Windows Server 2003";

                        return "Windows Server 2003 R2";
                    }

                    return "Windows XP";

                case 6:
                    if (vs.Minor == 0)
                    {
                        if (IsServerVersion()) return "Windows Server 2008";

                        return "Windows Vista";
                    }

                    if (vs.Minor == 1)
                    {
                        if (IsServerVersion()) return "Windows Server 2008 R2";

                        return "Windows 7";
                    }

                    if (vs.Minor == 2) return "Windows 8";

                    if (IsServerVersion()) return "Windows Server 2012 R2";

                    return "Windows 8.1";
            }
        }
    }

    public static string OperatingSystemServicePack
    {
        get
        {
            var os = new OSVERSIONINFO { dwOSVersionInfoSize = Marshal.SizeOf(typeof (OSVERSIONINFO)) };
            WindowsAPI.GetVersionEx(ref os); 
            return string.IsNullOrEmpty(os.szCSDVersion) ? "No Service Pack" : os.szCSDVersion; 
        }
    }

    public static bool IsProcessElevated
    {
        get
        {
            if (IsUacEnabled)
            {
                IntPtr tokenHandle;
                if (!OpenProcessToken(Process.GetCurrentProcess().Handle, TOKEN_READ, out tokenHandle))
                {
                    throw new ApplicationException("Could not get process token.  Win32 Error Code: " + Marshal.GetLastWin32Error());
                }

                var elevationResult = TOKEN_ELEVATION_TYPE.TokenElevationTypeDefault;

                int elevationResultSize = Marshal.SizeOf((int)elevationResult);
                uint returnedSize = 0;
                IntPtr elevationTypePtr = Marshal.AllocHGlobal(elevationResultSize);

                bool success = GetTokenInformation(tokenHandle, TOKEN_INFORMATION_CLASS.TokenElevationType, elevationTypePtr, (uint)elevationResultSize, out returnedSize);
                if (success)
                {
                    elevationResult = (TOKEN_ELEVATION_TYPE)Marshal.ReadInt32(elevationTypePtr);
                    bool isProcessAdmin = elevationResult == TOKEN_ELEVATION_TYPE.TokenElevationTypeFull;
                    return isProcessAdmin;
                }
                else
                {
                    throw new ApplicationException("Unable to determine the current elevation.");
                }
            }
            else
            {
                WindowsIdentity identity = WindowsIdentity.GetCurrent();
                WindowsPrincipal principal = new WindowsPrincipal(identity);
                return principal.IsInRole(WindowsBuiltInRole.Administrator);
            }
        }
    }
    
    private static bool IsServerVersion() 
    { 
        using (ManagementObjectSearcher searcher = new ManagementObjectSearcher("SELECT * FROM Win32_OperatingSystem")) 
        { 
            foreach (ManagementObject managementObject in searcher.Get()) 
            { 
                // ProductType will be one of: 
                // 1: Workstation 
                // 2: Domain Controller 
                // 3: Server 
                uint productType = (uint)managementObject.GetPropertyValue("ProductType"); 
                return productType != 1; 
            } 
        } 
        return false; 
    } 
    
    private static bool IsUacEnabled
    {
        get
        {
            RegistryKey uacKey = Registry.LocalMachine.OpenSubKey(uacRegistryKey, false);
            return uacKey.GetValue(uacRegistryValue).Equals(1);
        }
    }
}

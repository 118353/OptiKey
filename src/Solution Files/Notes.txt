NEXT STEPS:

Simplify OutputService.PublishModifiedVirtualKeyCodeSet
	Create DISTINCT set of all keys from supplied FunctionKey/Char KeyDownStates which are ON (not lock) + have a virtual key code set.
	Convert to extension method.

Make Multi-key capture & publish Lock instead of On

OutputService changes:
	ReleaseUnlockedModifiers(); every time UseAndPublish is called as a key was pressed.
		EXCEPT when modifier (Shift,Ctrl,Alt,Win) is pressed - make these a special case in the switch to do nothing.
	Change OutputService interface:
		UseAndPublish(FunctionKey/String)
		PublishKeyDown(FunctionKey/String)
		PublishKeyUp(FunctionKey/String)

Change MainVM to publish keydown/keyup when key down states move to/from LOCK. This provides the ability to hold down keys (e.g. Alt+Tab+Tab+Tab).
	This should solve: Known limitation; cannot hold down a modifier, e.g. holding down Alt and toggling with Tab, then releasing Alt when selection is as we want it. This would be solved by simulating key downs (for modifiers) and then key ups as they are released, but this requires synchronising all key states on startup and shutdown (could manage this from the KeyDownStates class). Need to test this again as previously this didn’t work.

Win key should be tri-state - it can be used as a modifier so add to all modifier logic.

Fix publish bugs (timing between key presses?) (keys behaving as if Ctrl is pressed):
	Move InputSimulator 'WindowsInput' project into solution.
	Remove InputBuilder.AddKeyPress - replace calls from KeyboardSimulator with chained AddKeyDown(x).AddKeyUp(x)
	Remove InputBuilder helper methods such as ModifiersDown/ModifiersUp/KeyPress(builder, keyCodes) - make the logic more explicit
	Rename InputBuilder.ToArray() to InputBuilder.Build() - it is the builder pattern after all
	Remove Sleep and other methods I am not using - the fixes can be back ported later, which needs to be manual anyway.
	Reorder InputBuilder and KeyboardSimulator methods to group them together in a nicer way - lots of overloads at the moment
	Add param to SendSimulatedInput and flesh it out:
		bool compatibilityMode (dispatches inputs individually with conditional delays after each in an attempt to simulator MS' On-Screen Keyboard behaviour)
	Change the content of ki INPUT to match OSK.exe

Move sleep into keyboards (replace Sleep in More keyboard with Recalibrate). Make Space 2 keys wide and add Sleep in bottom right?

Instantiate services AFTER View has loaded - this gives us the chance to display a notification message if services error during initialisation (e.g. InputService can publish an Error event if the TET service is not running, but this will not be displayed. It also prevents clean shutdown.)

Add settings
	+ normal settings (hotkey window)
	+ accessible settings - keyboard style
		* include ability to move and resize keyboard

Recalibrate
	
Dictionary management window
	+ Add
	+ Remove
	
Add high contrast theme

Profile and optimise, especially keyboard transitions

Refactor any remaining large classes, e.g. MainViewModel

--------------------------------------------------------------------------------

TO DO?
Store usage statistics in a case sensitive way? Would need to keep track of originally cased entries (incl. suggestions). Does this have any benefit? Think about whole advantage of storing usage statistics. 
Character codes – ALT on/lock, then numbers, then ALT off
Auto complete words
	+ auto correct words
Predict next word
Defend user against moving to Metro interface - i.e. LWIN/RWIN/WIN pressed on its own (in Win 8/8.1/later versions?)
	Make them confirm that they want to do this?
	Provide a way back from Metro - can I still detect point location and provide a way back?

--------------------------------------------------------------------------------

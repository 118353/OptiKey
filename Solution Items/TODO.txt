Why is windows 8.1 reporting itself as 6.2 (Windows 8) rather than 6.3.
	Ok when exe run directly, but not when run using visual studio debugging.

Start contacting people - screenshots

Combine move and resize keyboards
	Rename MoveAndResizeService to WindowManipulationService
	Test opacity then add opacity logic to WindowManipulationService and keys

Get a certificate (1), sign the release build (2) and package ETTA to install to Program Files directory (3) - required to be get UI Access and stay on top of Metro
	Free (1 year trial?) certificate for Open Source projects; https://www.certum.eu/certum/cert,offer_en_open_source_cs.xml
		http://stackoverflow.com/questions/1177552/code-signing-certificate-for-open-source-projects
	Steps to sign are in file "Certificates and Signing.txt".
	Sign in post-build?
	
Set a different manifest if building in Release mode - including uiAccess request.

Publish as ClickOnce
	http://elbruno.com/2013/06/01/azure-howto-publish-a-clickonce-application-using-and-azure-website/

Think about how to pause/prevent the point source during multi-key selection processing.
	Disabling all points prevents the Multi-key selection trigger storyboard from playing as the disabled datatrigger is taking precedence.
		CAN I MAKE THE ANIMATION TAKE CORRECT PRECEDENCE?

Pause point source when switching keyboards - on unload/load of content of Keyboard host, i.e. when KeyboardHost.Content changes
	Need to make sure KeyValueMap is nulled out when a keyboard changes, and only gets set again when the view is rendered fully?
	Do some testing around when the newContent.Loaded event fires, compared to when the Content is set, and the ContentRendered event fires. I think Loaded on the content is best, but still test.
		http://msdn.microsoft.com/en-us/library/ms748948.aspx#Window_Lifetime_Events
		http://msdn.microsoft.com/en-us/library/system.windows.frameworkelement.loaded(v=vs.110).aspx
	In GenerateContent - set PointToKeyValueMap = null; before changing the content.
	Optimise RebuildPointToKeyMap:
		a)If Content == null then PointToKeyValueMap = null
		b)Find Keys from Content, not from top layer. There won't be any and this is extra work.

Profile and optimise, especially keyboard transitions
	http://blogs.msdn.com/b/visualstudioalm/archive/2014/02/28/new-cpu-usage-tool-in-the-performance-and-diagnostics-hub-in-visual-studio-2013.aspx
	http://blogs.msdn.com/b/visualstudio/archive/2014/06/12/new-memory-usage-tool-for-wpf-and-win32-applications.aspx
	
Refactor any remaining large classes, e.g. MainViewModel
	Create new 'InputBroker'/'InputHandler'/'InputRouter' class which takes the view model, input service, outputservice, etc and coordinates the response

Preview settings in management console

!Release down keys logic seems to release keys which aren't down, e.g. F4 on shutdown!

Prevent minimising? Listen to state change and restore?

--------------------------------------------------------------------------------

TO DO?
Add transparency - accessible from keyboard? Just sent Window.Opacity?
Add support for USB (hardware) buttons (to act as triggers)?
Store usage statistics in a case sensitive way? Would need to keep track of originally cased entries (incl. suggestions). Does this have any benefit? Think about whole advantage of storing usage statistics. 
Character codes â€“ ALT on/lock, then numbers, then ALT off
Auto complete words
	+ auto correct words
Predict next word
Add high contrast theme
Test this product: http://www.cameramouse.org/
Get and test the Tobii EyeX: http://www.tobii.com/en/eye-experience/#.UwMlifl5OkF

No position input possible - automatically cycle through groups of keys, then keys in group: 
	Keyboards could define ordered set of KeyValues; the key "groups"
	New SelectionMode = KeyGroups - this then changes to PositionSource to a source which automatically loops through the current keyboard's groups.
	Position source can output more than one current point: CurrentKey would become a set (allowing the highlighting of a group of keys)
	Selection (of a set of KeyValues) when SelectionMode = KeyGroups does not produce a SelectionResult, but instead disables all keys not in the group (not explicitly, but instead based on a property, e.g. CurrentKeyGroup). SelectionMode then changes to Key.
	In Key mode the position source could iterate through all enabled keys in the key map (which should be the selected group of keys).
		Selection => normal key selection and reset mode back to KeyGroups.
		? If no selection in X iterations through the keys then output a special selection, e.g. a null selection (the trigger can watch the position source, like the fixation triggers.
	Each key group should contain a 'back' key to return from group selection?
	
Add support for T9 style selection; either individual keys, or multi key select?



!!! If DropBox creates another conflicted copy: http://stackoverflow.com/questions/12773488/git-fatal-reference-has-invalid-format-refs-heads-master






<Window x:Class="JuliusSweetland.ETTA.UI.Windows.DictionaryManagementWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:i="http://schemas.microsoft.com/expression/2010/interactivity"
        xmlns:interactionRequest="http://www.codeplex.com/prism"
        xmlns:controls="clr-namespace:JuliusSweetland.ETTA.UI.Controls"
        mc:Ignorable="d" 
        d:DesignHeight="300" d:DesignWidth="500"
        Height="600" Width="Auto" MinWidth="300"
        SizeToContent="Width"
        WindowStartupLocation="CenterOwner"
        Name="dictionaryWindow">

    <i:Interaction.Triggers>
        <interactionRequest:InteractionRequestTrigger SourceObject="{Binding ConfirmationRequest, Mode=OneWay}">
            <controls:ConfirmationWindowAction />
        </interactionRequest:InteractionRequestTrigger>
    </i:Interaction.Triggers>
    
    <Window.Resources>
        <CollectionViewSource x:Key="EntryWithUsageCountCollectionViewSource" Source="{Binding EntriesWithUsageCount}" />
    </Window.Resources>
    
    <Grid IsSharedSizeScope="True">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="*" />
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>
        
        <TextBlock Grid.Row="0" Text="Dictionary" FontSize="20" FontWeight="Bold" Margin="10,5,5,5" />

        <ItemsControl Grid.Row="1"
                      VirtualizingStackPanel.IsVirtualizing="True"
                      ScrollViewer.CanContentScroll="True"
                      ItemsSource="{Binding Source={StaticResource EntryWithUsageCountCollectionViewSource}, Mode=OneWay}">
            <ItemsControl.ItemTemplate>
                <DataTemplate>
                    <Grid>
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="*" />
                            <ColumnDefinition Width="Auto" SharedSizeGroup="ButtonColumn" />
                        </Grid.ColumnDefinitions>

                        <Label Grid.Column="0" Content="{Binding Entry}" FontSize="16" 
                               HorizontalAlignment="Left" VerticalAlignment="Center" Margin="10,2,5,2" />

                        <Button Grid.Column="1" Content="  Delete  " 
                                HorizontalAlignment="Right" VerticalAlignment="Center" Margin="5,2,10,2" Height="20"
                                Command="{Binding RelativeSource={RelativeSource AncestorType={x:Type ItemsControl}}, Path=DataContext.RemoveEntryWithUsageCountCommand}" 
                                CommandParameter="{Binding}" />
                    </Grid>
                </DataTemplate>
            </ItemsControl.ItemTemplate>
            <ItemsControl.ItemsPanel>
                <ItemsPanelTemplate>
                    <VirtualizingStackPanel />
                </ItemsPanelTemplate>
            </ItemsControl.ItemsPanel>
            <ItemsControl.Template>
                <ControlTemplate>
                    <Border BorderThickness="{TemplateBinding Border.BorderThickness}"
                            Padding="{TemplateBinding Control.Padding}"
                            BorderBrush="{TemplateBinding Border.BorderBrush}"
                            Background="{TemplateBinding Panel.Background}"
                            SnapsToDevicePixels="True">
                        <ScrollViewer Padding="{TemplateBinding Control.Padding}" Focusable="False">
                            <ItemsPresenter SnapsToDevicePixels="{TemplateBinding UIElement.SnapsToDevicePixels}" />
                        </ScrollViewer>
                    </Border>
                </ControlTemplate>
            </ItemsControl.Template>
        </ItemsControl>
        
        <Button Grid.Row="2" Command="{Binding OkCommand}" CommandParameter="{Binding ElementName=dictionaryWindow}" 
                Content="OK" Width="80" Margin="5" HorizontalAlignment="Right" />
    </Grid>
</Window>



using System;
using System.Collections.Generic;
using System.Windows;
using JuliusSweetland.ETTA.Model;
using JuliusSweetland.ETTA.Services;
using log4net;
using Microsoft.Practices.Prism.Commands;
using Microsoft.Practices.Prism.Interactivity.InteractionRequest;
using Microsoft.Practices.Prism.ViewModel;

namespace JuliusSweetland.ETTA.UI.ViewModels
{
    public class DictionaryManagementViewModel : NotificationObject
    {
        private readonly IDictionaryService dictionaryService;

        #region Private Member Vars

        private readonly static ILog Log = LogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);

        #endregion

        #region Ctor

        public DictionaryManagementViewModel(IDictionaryService dictionaryService)
        {
            this.dictionaryService = dictionaryService;

            if (dictionaryService == null)
            {
                throw new ApplicationException("IDictionaryService not supplied to DictionaryManagementViewModel - unable to continue");
            }

            //Instantiate notification request(s)
            ConfirmationRequest = new InteractionRequest<Confirmation>();

            //Instantiate commands
            RemoveEntryWithUsageCountCommand = new DelegateCommand<EntryWithUsageCount>(RemoveEntryWithUsageCount);
            OkCommand = new DelegateCommand<Window>(Ok); //Can always click Ok
        }

        #endregion

        #region Properties

        public IEnumerable<EntryWithUsageCount> EntriesWithUsageCount
        {
            get { return dictionaryService.GetAllEntriesWithUsageCounts(); }
        }

        public InteractionRequest<Confirmation> ConfirmationRequest { get; private set; }

        public DelegateCommand<EntryWithUsageCount> RemoveEntryWithUsageCountCommand { get; private set; }
        public DelegateCommand<Window> OkCommand { get; private set; }
        
        #endregion

        #region Remove Entry With Usage Count

        private void RemoveEntryWithUsageCount(EntryWithUsageCount entryWithUsageCount)
        {
            ConfirmationRequest.Raise(new Confirmation
                {
                    Title = "Delete this entry?", 
                    Content = string.Format("Are you sure that you want to remove entry '{0}' from the dictionary?", entryWithUsageCount.Entry)
                }, confirmation => 
                {
                    if (confirmation.Confirmed)
                    {
                        dictionaryService.RemoveEntryFromDictionary(entryWithUsageCount);

                        RaisePropertyChanged(() => EntriesWithUsageCount);
                    }
                });
        }
        
        #endregion

        #region Ok

        private void Ok(Window window)
        {
            window.Close();
        }

        #endregion
    }
}
